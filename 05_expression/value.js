'use strict';

// 값(value) : 식(표현식, expression)이 평가(evaluate)되어 생성된 결과
var sum = 10 + 20;

// sum 변수에 할당되는 것은 10 + 20 이 아니라 10 + 20 이 평가된 결과인 숫자 값 30 임.
// 10 + 20 은 할당 이전에 평가되어 값을 생성해야함.


// 리터럴(literal)은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법(notation)
// 값을 생성하기 위해 미리 약속한 표기법이라고 할 수 있음.
// 숫자 리터럴 3
3

// 표현식(expression)은 값으로 평가될 수 있는 문(statement)이다. 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.
// 리터럴은 그 자체로 표현식임.

// 리터럴 표현식
10
'hihi~~'

// 식별자 표현식(선언이 이미 존재했다고 가정)
sum
person.name
arr[1]

// 연산자 표현식
10 + 20
sum = 10
sum !== 10

// 함수/메서드 호출 표현식(선언이 이미 존재했다고 가정)
makeCake()
person.getName()

// 값이 위치할 수 있는 자리에는 표현식도 위치할 수 있다는 것을 의미
// 표현식은 다른 표현식의 일부가 되어 새로운 값을 만들어낼 수 있다.


// 문(statement) : 프로그램을 구성하는 기본 단위이자 최소 실행 단위. 선언문, 할당문, 조건문, 반복문 등...
// 문을 명령문이라고도 부른다. 즉, 문은 컴퓨터에 내리는 명령임. 문이 실행되면 명령이 실행되고 무슨 일인가가 일어나게 된다.

// 토큰(token) : 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미


// 세미콘은(;)은 문의 종료를 나타냄.
// javascript 엔진이 소스코드를 해석할 때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 
// 세미콜론 자동 삽입 기능(ASI : automatic semicolon insertion)이 암묵적으로 수행되기 때문이다.
function foo () {
    return
        {}
    // ASI의 동작 결과 => return; {};
    // 개발자의 예측 => return {};
}
console.log('foo()', foo());

var bar = function () {}
(function() {})();
// ASI의 동작 결과 => var bar = function () {}(function() {})();
// 개발자의 예측 => var bar = function () {}; (function() {})();
// TypeError: (intermediate value)( ... ) is not a function

// 전체적으로 세미콜론 사용을 권장하는 분위기다. 그냥 붙이자...


// 표현식인 문과 표현식이 아닌 문이 있다. 표현식인 문은 값으로 평가될 수 있는 문이며, 
// 표현식이 아닌 문은 값으로 평가될 수 없는 문을 말함.
// 따라서, 변수 선언문은 값으로 평가될 수 없다. => 표현식이 아님!!
// 표현식인 문과 표현식이 아닌 문을 구별하는 가장 간단하고 명료한 방법은 변수에 할당해 보는 것
// var foo = var x; // SyntaxError: Unexpected token var

// 할당문은 그 자체서 표현식이지만 완전한 문이기도 하다. 즉, 할당문은 표현식인 문이다.
x = 100;

// x = 100 은 표현식이므로 변수에 할당 가능
var foo = x = 100;
